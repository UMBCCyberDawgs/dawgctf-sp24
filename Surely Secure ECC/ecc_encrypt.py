import random

# Define parameters for secp256k1 curve

# Prime modulus of the field over which the curve is defined. The size of the field
# determines the difficulty of cryptographic operations. For secp256k1, it is a very large prime number.
p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F 

# The coefficient 'a' in the elliptic curve equation of the form y^2 = x^3 + ax + b.
# For secp256k1, this value is zero.
a = 0

# The coefficient 'b' in the elliptic curve equation of the form y^2 = x^3 + ax + b.
# For secp256k1, this value is seven (7).
b = 7

# The x-coordinate of the base point (also called the generator point) on the elliptic curve.
# This point is used in the scalar multiplication to generate other points on the curve.
Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798

# The y-coordinate of the base point on the elliptic curve. Together with Gx, this point
# (Gx, Gy) forms the generator point G that is used in cryptographic operations.
Gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8

# The order of the base point G. It is the number of times the base point must be
# added to itself to get back to the identity element of the curve (point at infinity).
# It's used to define the cyclic subgroup generated by G, crucial for defining the
# boundaries of valid private keys in ECC.
n = (Gx * Gy) % p


# Define elliptic curve point class
class ECPoint:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        return f"({hex(self.x)}, {hex(self.y)})"
    

# Define addition of points on the elliptic curve
def point_addition(P, Q):
    if P is None:
        return Q
    if Q is None:
        return P
    if P.x == Q.x and P.y != Q.y:
        return None

    if P.x == Q.x:
        m = (3 * P.x * P.x) * pow(2 * P.y, p - 2, p)
    else:
        m = (Q.y - P.y) * pow(Q.x - P.x, p - 2, p)

    Rx = (m * m - P.x - Q.x) % p
    Ry = (m * (P.x - Rx) - P.y) % p

    return ECPoint(Rx, Ry)

# Define scalar multiplication on the elliptic curve
def scalar_multiplication(k, P):
    if k == 0 or P is None:
        return None
    Q = None
    while k > 0:
        if k % 2 == 1:
            Q = point_addition(Q, P)
        P = point_addition(P, P)
        k //= 2
    return Q

if __name__ == "__main__":
    # Select a private key
    private_key = random.randrange(1, n)
    G = ECPoint(Gx, Gy)

    # Generate the public key
    public_key = scalar_multiplication(n, G)
